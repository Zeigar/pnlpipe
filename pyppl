#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelinelib
from pipelinelib import logfmt, Src, update
from nodes import StrctXc, DwiXc, FsInDwiDirect, FreeSurferUsingMask, T1wMaskMabs, DwiMaskHcpBet, DwiEd, UkfDefault, Wmql, TractMeasures, T2wMaskRigid, DwiEpi, getBrainsToolsPath, getUKFTractographyPath, getTractQuerierPath, getTrainingDataT1AHCCCsv, DoesNotExistException
import nodes

BTHASHES = ['41353e8']
TQHASHES = ['e045eab']
UKFHASHES = ['421a7ad']

def makeTreeDict(pipeline):
    tree = {}
    for keyname, node in pipeline.items():
        if keyname == 'name':
            continue
        tree[node.show()] = {dep.show() for dep in node.deps}
    return tree


def assertKeys(pipelineName, keys):
    absentKeys = [k for k in keys if not pipelinelib.INPUT_PATHS.get(k)]
    if absentKeys:
        for key in absentKeys:
            print("{} requires '{}' set in _inputPaths.yml".format(
                pipelineName, key))
        sys.exit(1)


def makeStandardPipeline(caseid,
                         ukfhash,
                         tqhash,
                         dwiKey='dwi',
                         t1Key='t1',
                         dwimaskKey='dwimask',
                         ukfparams=None):
    """Makes the PNL's standard pipeline. """

    pipeline = { 'name' : "standard PNL pipeline" }
    assertKeys(pipeline['name'], [dwiKey, t1Key])

    pipeline['t1'] = Src(caseid, t1Key)
    pipeline['dwi'] = Src(caseid, dwiKey)

    pipeline['t1xc'] = StrctXc(caseid, pipeline['t1'])
    # run DwiXc first as it's able to convert a DWI nifti to nrrd
    pipeline['dwixc'] = DwiXc(caseid, pipeline['dwi'])
    pipeline['dwied'] = DwiEd(caseid, pipeline['dwixc'])

    pipeline['dwimask'] = Src(
        caseid, dwimaskKey) if pipelinelib.INPUT_PATHS.get(
            dwimaskKey) else DwiMaskHcpBet(caseid, pipeline['dwied'])

    pipeline['t1mask'] = Src(
        caseid,
        't1mask') if pipelinelib.INPUT_PATHS.get('t1mask') else T1wMaskMabs(
            caseid, pipeline['t1xc'])

    pipeline['fs'] = FreeSurferUsingMask(caseid, pipeline['t1xc'],
                                         pipeline['t1mask'])
    pipeline['fsindwi'] = FsInDwiDirect(caseid, pipeline['fs'],
                                        pipeline['dwied'], pipeline['dwimask'])

    pipeline['ukf'] = UkfDefault(caseid, pipeline['dwied'],
                                 pipeline['dwimask'], ukfhash)

    pipeline['wmql'] = Wmql(caseid, pipeline['fsindwi'], pipeline['ukf'],
                            tqhash)
    pipeline['tractmeasures'] = TractMeasures(caseid, pipeline['wmql'])
    return pipeline


def makeStandardEpiPipeline(caseid,
                            ukfhash,
                            tqhash,
                            dwiKey='dwimask',
                            t1Key='t1',
                            t2Key='t2',
                            dwimaskKey='dwimask'):
    """Makes the PNL's standard pipeline with EPI distortion correction. """

    pipeline = { 'name' :  "EPI correction pipeline" }
    assertKeys(pipeline['name'], [dwiKey, t1Key, t2Key])

    pipeline['t1'] = Src(caseid, t1Key)
    pipeline['dwi'] = Src(caseid, dwiKey)
    pipeline['t2'] = Src(caseid, 't2')

    pipeline['t1xc'] = StrctXc(caseid, pipeline['t1'])
    pipeline['t2xc'] = StrctXc(caseid, pipeline['t2'])
    # run DwiXc first as it's able to convert a DWI nifti to nrrd
    pipeline['dwixc'] = DwiXc(caseid, pipeline['dwi'])
    pipeline['dwied'] = DwiEd(caseid, pipeline['dwixc'])

    pipeline['dwimask'] = Src(
        caseid, dwimaskKey) if pipelinelib.INPUT_PATHS.get(
            dwimaskKey) else DwiMaskHcpBet(caseid, pipeline['dwied'])

    pipeline['t1mask'] = Src(
        caseid,
        't1mask') if pipelinelib.INPUT_PATHS.get('t1mask') else T1wMaskMabs(
            caseid, pipeline['t1xc'])

    pipeline['t2mask'] = Src(
        caseid,
        't2mask') if pipelinelib.INPUT_PATHS.get('t2mask') else T2wMaskRigid(
            caseid, pipeline['t2xc'], pipeline['t1xc'], pipeline['t1mask'])

    pipeline['dwiepi'] = DwiEpi(caseid, pipeline['dwied'], pipeline['dwimask'],
                                pipeline['t2xc'], pipeline['t2mask'])

    pipeline['fs'] = FreeSurferUsingMask(caseid, pipeline['t1xc'],
                                         pipeline['t1mask'])
    pipeline['fsindwi'] = FsInDwiDirect(caseid, pipeline['fs'],
                                        pipeline['dwied'], pipeline['dwimask'])

    pipeline['ukf'] = UkfDefault(caseid, pipeline['dwied'],
                                 pipeline['dwimask'], ukfhash)

    pipeline['wmql'] = Wmql(caseid, pipeline['fsindwi'], pipeline['ukf'],
                            tqhash)
    pipeline['tractmeasures'] = TractMeasures(caseid, pipeline['wmql'])
    return pipeline


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelinelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelinelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelinelib.INPUT_PATHS = yaml.load(f)
    # local.path(pipelinelib.OUTDIR).mkdir()


class App(cli.Application):
    """Runs the PNL pipeline using the input paths in _inputPaths.yml"""
    want = cli.SwitchAttr(
        ['-w', '--want'], default='tractmeasures', help='target node')
    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code


@App.subcommand('setup')
class Setup(cli.Application):
    """Makes prerequisite software given the hashes defined at the top of the file."""

    def main(self):
        from pnlscripts.util.scripts import software_py

        for ukfhash in UKFHASHES:
            try:
                getUKFTractographyPath(ukfhash) # throws error if doesn't exist
            except DoesNotExistException:
                print('Make UKFTractography')
                software_py['--commit', ukfhash, 'ukftractography'] & FG

        for bthash in BTHASHES:
            try:
                getBrainsToolsPath(bthash)
            except DoesNotExistException:
                print('Make BRAINSTools')
                software_py['--commit', bthash, 'brainstools'] & FG

        for tqhash in TQHASHES:
            try:
                getTractQuerierPath(tqhash)
            except DoesNotExistException:
                print('Make tract_querier')
                software_py['--commit', bthash, 'tractquerier'] & FG

        try:
            getTrainingDataT1AHCCCsv()
        except DoesNotExistException:
            print('Make training T1s')
            software_py['trainingt1s'] & FG

        print('All necessary software installed:')
        print(getUKFTractographyPath(ukfhash))
        print(getBrainsToolsPath(bthash))
        print(getTractQuerierPath(tqhash))
        print(getTrainingDataT1AHCCCsv())


class PipelineSubcommand(cli.Application):
    def main(self, *caseids):

        readAndSetInputPaths()  # reads _inputPaths.yml into pipelinelib.INPUT_PATHS
        caseids = caseids if caseids else [
            pipelinelib.INPUT_PATHS.get('caseid')
        ]

        if self.parent.writeGeneratedPathsYml:
            writeGeneratedPathsYml(caseids[0], self.pipelines)
            return

        for caseid in caseids:
            for bthash in BTHASHES:
                nodes.BTHASH = bthash
                for pipeline in self.pipelines(caseid):
                    if pipeline.get('name'):
                        print('Running {} on case id {}'.format(pipeline['name'], caseid))
                    update(pipeline[self.parent.want])


@App.subcommand("std")
class Std(PipelineSubcommand):
    """ Run standard PNL pipeline. """
    dwiKey = cli.SwitchAttr(
        ['--dwikey'], help='DWI key', default='dwi', mandatory=False)
    t1Key = cli.SwitchAttr(
        ['--t1key'], help='T1w key', default='t1', mandatory=False)
    dwimaskKey = cli.SwitchAttr(
        ['--dwimaskey'],
        help='DWI mask key',
        default='dwimask',
        mandatory=False)

    def pipelines(self, caseid):
        for ukfhash in UKFHASHES:
            for tqhash in TQHASHES:
                yield makeStandardPipeline(caseid, ukfhash, tqhash,
                                           self.dwiKey, self.t1Key,
                                           self.dwimaskKey)


@App.subcommand("epi")
class Epi(PipelineSubcommand):
    """ Run Epi correction PNL pipeline. """
    dwiKey = cli.SwitchAttr(
        ['--dwikey'], help='DWI key', default='dwi', mandatory=False)
    t1Key = cli.SwitchAttr(
        ['--t1key'], help='T1w key', default='t1', mandatory=False)
    dwimaskKey = cli.SwitchAttr(
        ['--dwimaskey'],
        help='DWI mask key',
        default='dwimask',
        mandatory=False)
    t2Key = cli.SwitchAttr(
        ['--t2key'], help='T2w key', default='t2', mandatory=False)

    def pipelines(self, caseid):
        for ukfhash in UKFHASHES:
            for tqhash in TQHASHES:
                yield makeStandardEpiPipeline(caseid, ukfhash, tqhash,
                                              self.dwiKey, self.t1Key,
                                              self.t2Key, self.dwimaskKey)


@App.subcommand("custom")
class Custom(PipelineSubcommand):
    """Run a custom pipeline (edit pyppl) """

    def pipelines(self, caseid):
        print('Uncomment and edit code below to make a custom pipeline')
        return []
        # Examples:
        # return [makeStandardPipeline(caseid, ukfhash, tqhash, ukfparams) for ukfparams in [ukfparamsDefault, ukfparamsCustom]


if __name__ == '__main__':
    App.run()
