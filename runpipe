#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelinelib
from pipelinelib import logfmt, update
import itertools


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelinelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelinelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelinelib.INPUT_PATHS = yaml.load(f)
    # local.path(pipelinelib.OUTDIR).mkdir()

def loadSubmodules(package):
    import pkgutil
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        yield importer.find_module(modname).load_module(modname)


class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], default='tractmeasures', help='target node')

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)
    paramsList = []
    for paramsDict in yml:
        flatDict = dict(paramsDict['software'], **{ k:v for k,v in paramsDict.items() if k != 'software'})
        keys = flatDict.keys()
        valueCombos = itertools.product(*flatDict.values())
        ps = [zip(keys, combo) for combo in valueCombos]
        paramsList.append(ps)
    return paramsList


class PipelineSubcommand(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads _inputPaths.yml into pipelinelib.INPUT_PATHS
        params = readParams(self.paramsFile)
        from pprint import pprint
        pprint(params)
        # self.makePipeline(*params)

def classFactory(name, fn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return fn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        SubcommandClass = classFactory(m.__name__, m.makePipeline)
        App.subcommand(m.__name__, SubcommandClass)
    App.run()
