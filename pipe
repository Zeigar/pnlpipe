#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelib
import pipelib
import itertools
import importlib
from pprint import pprint


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelib.INPUT_PATHS = yaml.load(f)

def loadSubmodules(package):
    import pkgutil
    from os.path import isfile
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        if modname.startswith('pipe'):
            yield importer.find_module(modname).load_module(modname)

class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], help='target node to build, e.g. fsindwi')

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def concat(l):
    return l if l == [] else [item for sublist in l for item in sublist]

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)
    if not isinstance(yml, list):
        yml = [yml]
    for idx, p in enumerate(yml):
        if not p.get('caseid', None):
            caselist = local.path('caselist.txt')
            if not caselist.exists():
                print("Add 'caseid' to {} (or save a caselist.txt to this directory)".format(ymlfile))
                sys.exit(1)
            print("Found './caselist.txt, using that to get case id's")
            yml[idx]['caseid'] = './' + str(caselist).replace(local.cwd, '')
    return yml


def expandParams(yml):
    paramsList = []
    for paramsDict in yml:
        flatDict = dict(paramsDict['software'], **{ k:v for k,v in paramsDict.items() if k != 'software'})
        # Turn values into lists if not already
        flatDict2 = dict((k,v) if isinstance(v, list) else (k,[v]) for k,v in flatDict.items())
        # Check if case ids are defined by a caselist
        if '/' in flatDict2['caseid'][0]:
            with open(flatDict2['caseid'][0],'r') as f:
                flatDict2['caseid'] = f.read().splitlines()

        keys = flatDict2.keys()
        valueCombos = itertools.product(*flatDict2.values())
        ps = [dict(zip(keys, combo)) for combo in valueCombos]
        paramsList.append(ps)
    return concat(paramsList)


class PipelineSubcommand(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

class Run(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads _inputPaths.yml into pipelib.INPUT_PATHS

        paramsList = expandParams(readParams(self.parent.paramsFile))

        for params in paramsList:
            print('Running {} pipeline with params:'.format(self.parent.__class__.__name__))
            pprint(params)

            pipeline = self.parent.makePipeline(**params)

            if not self.parent.parent.want:
                pipelib.update(pipeline['all'])
            else:
                pipelib.update(pipeline[self.parent.want])

class Make(cli.Application):
    def main(self):
        yml = readParams(self.parent.paramsFile)
        for paramsDict in yml:
            for softname, commits in paramsDict['software'].items():
                recipeFile = local.path('software') / (softname + '.py')
                if not recipeFile.exists():
                    print("{} does not exist, maybe there is a typo in '{}'?".format(recipeFile, self.parent.paramsFile))
                    sys.exit(1)
                for commit in commits:
                    m = importlib.import_module('software.' + softname)
                    print('Make {} with commit {}'.format(softname, commit))
                    m.make(commit)
        print('Done.')


def classFactory(name, fn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return fn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        name = m.__name__[9:]
        SubcommandClass = classFactory(name, m.makePipeline)
        App.subcommand(name, SubcommandClass)
        SubcommandClass.subcommand("run", Run)
        SubcommandClass.subcommand("make", Make)
    App.run()
