#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelib
from pipelib import logfmt, update
import itertools
import importlib


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelib.INPUT_PATHS = yaml.load(f)

def loadSubmodules(package):
    import pkgutil
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        if not modname.startswith('_'):
            yield importer.find_module(modname).load_module(modname)

class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], default='tractmeasures', help='target node')

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def concat(l):
    return l if l == [] else [item for sublist in l for item in sublist]

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)
    paramsList = []
    for paramsDict in yml:
        flatDict = dict(paramsDict['software'], **{ k:v for k,v in paramsDict.items() if k != 'software'})
        keys = flatDict.keys()
        valueCombos = itertools.product(*flatDict.values())
        ps = [dict(zip(keys, combo)) for combo in valueCombos]
        paramsList.append(ps)
    return concat(paramsList)


class PipelineSubcommand(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

class Run(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads _inputPaths.yml into pipelib.INPUT_PATHS
        paramsList = readParams(self.parent.paramsFile)
        from pprint import pprint
        for params in paramsList:
            print('Running {} pipeline with params:'.format(self.parent.__class__.__name__))
            pprint(params)
            self.parent.makePipeline(**params)

class Make(cli.Application):
    def main(self):
        with open(self.parent.paramsFile, 'r') as f:
            yml = yaml.load(f)
        for paramsDict in yml:
            for softname, commits in paramsDict['software'].items():
                for commit in commits:
                    m = importlib.import_module('software_recipes.' + softname)
                    print('Make {} with commit {}'.format(softname, commit))
                    m.make(commit)
        print('Done.')


def classFactory(name, fn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return fn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        SubcommandClass = classFactory(m.__name__, m.makePipeline)
        App.subcommand(m.__name__, SubcommandClass)
        SubcommandClass.subcommand("run", Run)
        SubcommandClass.subcommand("make", Make)
    App.run()
