#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelib
import pipelib
import itertools
import importlib
from pprint import pprint


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelib.INPUT_PATHS = yaml.load(f)

def loadSubmodules(package):
    import pkgutil
    from os.path import isfile
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        if modname.startswith('pipeline_'):
            yield importer.find_module(modname).load_module(modname)

class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], help='target node to build, e.g. fsindwi')

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def concat(l):
    return l if l == [] else [item for sublist in l for item in sublist]

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)

    result = []
    for idx, paramDict in enumerate(yml if isinstance(yml,list) else [yml]):
        listValueDict = dict((k,v) if isinstance(v, list) else
                             (k,[v]) for k,v in paramDict.items())
        if not paramDict.get('caseid'):
            caselist = local.path('caselist.txt')
            if not caselist.exists():
                print("Add 'caseid' to {} (or save a caselist.txt to this directory)".format(ymlfile))
                sys.exit(1)
            print("Found './caselist.txt, using that for case id's")
            listValueDict['caseid'] = ['./caselist.txt']
        result.append(listValueDict)

    print("Read parameter file '{}':".format(ymlfile))
    pprint(result)
    return result


def expandParams(params):
    paramsList = []
    for paramsDict in params:
        # Check if case ids are defined by a caselist
        if '/' in paramsDict['caseid'][0]:
            with open(paramsDict['caseid'][0],'r') as f:
                paramsDict['caseid'] = f.read().splitlines()
        keys = paramsDict.keys()
        valueCombos = itertools.product(*paramsDict.values())
        ps = [dict(zip(keys, combo)) for combo in valueCombos]
        paramsList.append(ps)
    return concat(paramsList)


class PipelineSubcommand(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

class Run(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads _inputPaths.yml into pipelib.INPUT_PATHS

        params = readParams(self.parent.paramsFile)
        if any('*mandatory*' in concat(p.values()) for p in params):
            print("'{}' has unfilled mandatory values, replace the '*mandatory*' fields first and then rerun the pipeline.".format(self.parent.paramsFile))
            sys.exit(1)

        paramsList = expandParams(params)

        for params in paramsList:
            print('Running {} pipeline with paramaters:'.format(self.parent.__class__.__name__))
            pprint(params)

            pipeline = self.parent.makePipeline(**params)

            if not self.parent.parent.want:
                pipelib.update(pipeline['all'])
            else:
                pipelib.update(pipeline[self.parent.want])

class Make(cli.Application):
    """ Builds necessary software for pipeline. """

    def main(self):
        yml = readParams(self.parent.paramsFile)
        for paramsDict in yml:
            for softname, commits in [(k[5:],v) for (k,v) in paramsDict.items() if k.startswith('hash_')]:
                recipeFile = local.path('software') / (softname + '.py')
                if not recipeFile.exists():
                    print("{} does not exist, maybe there is a typo in '{}'?".format(recipeFile, self.parent.paramsFile))
                    sys.exit(1)
                for commit in commits:
                    m = importlib.import_module('software.' + softname)
                    print('Make {} with commit {}'.format(softname, commit))
                    m.make(commit)
        print('Done.')

class Init(cli.Application):
    """Makes parameter file that is used as input for this pipeline."""

    force = cli.Flag(['--force'], help='Force overwrite existing paramater file.')

    def main(self):
        paramsFile = 'params.' + self.parent.__class__.__name__
        if local.path(paramsFile).exists() and not self.force:
            print("'{}' already exists, won't overwrite (use '--force' to overwrite it).".format(paramsFile))
            return
        local.path(paramsFile).delete()
        import inspect
        from itertools import izip_longest
        from collections import OrderedDict
        args, _, _, defaults = inspect.getargspec(self.parent.makePipeline_orig)
        x = izip_longest(reversed(args), reversed(defaults), fillvalue='*mandatory*')
        x = OrderedDict(reversed(list(x)))
        """ http://stackoverflow.com/a/8661021 """
        represent_dict_order = lambda self, data:  self.represent_mapping('tag:yaml.org,2002:map', data.items())
        yaml.add_representer(OrderedDict, represent_dict_order)
        help_message = \
"""# Note: 'caseid' can be removed if you have a caselist.txt file."
# Otherwise, use the format of one of these examples:
# caseid: 001
# caseid: [001, 002, 003]
# caseid:
#    - 001
#    - 002
#    - 003
# caseid: ./caselist-controls.txt

"""
        with open(paramsFile, 'w') as f:
            f.write(help_message)
            yaml.dump(x, f, default_flow_style=False)
        print("Made '{}'".format(paramsFile))


def classFactory(name, makePipelineFn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return makePipelineFn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"makePipeline_orig": makePipelineFn
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        name = m.__name__[9:]
        SubcommandClass = classFactory(name, m.makePipeline)
        App.subcommand(name, SubcommandClass)
        SubcommandClass.subcommand("run", Run)
        SubcommandClass.subcommand("make", Make)
        SubcommandClass.subcommand("init", Init)
    App.run()
