#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pyppl)')
import sys
import yaml
import pipelib
from pipelib import logfmt, update
import itertools
import importlib


def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path('_inputPaths.yml').exists():
        print(
            "Missing _inputPaths.yml, first make one using 'pnlscripts/makepathsyml.py' or a text editor")
        sys.exit(1)
    with open('_inputPaths.yml', 'r') as f:
        pipelib.INPUT_PATHS = yaml.load(f)

def loadSubmodules(package):
    import pkgutil
    from os.path import isfile
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        if modname.startswith('pipe'):
            yield importer.find_module(modname).load_module(modname)

class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], default='tractmeasures', help='target node')

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def concat(l):
    return l if l == [] else [item for sublist in l for item in sublist]

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)
    if not isinstance(yml, list):
        yml = [yml]
    for p in yml:
        if not p.get('caseid', None):
            print('caseid missing in {}'.format(ymlfile))
            sys.exit(1)
    return yml


def expandParams(yml):
    paramsList = []
    for paramsDict in yml:
        flatDict = dict(paramsDict['software'], **{ k:v for k,v in paramsDict.items() if k != 'software'})
        # Turn values into lists if not already
        flatDict2 = dict((k,v) if isinstance(v, list) else (k,[v]) for k,v in flatDict.items())
        # Check if case ids are defined by a caselist
        print flatDict2['caseid'][0]
        if '/' in flatDict2['caseid'][0]:
            with open(flatDict2['caseid'][0],'r') as f:
                flatDict2['caseid'] = f.read().splitlines()

        keys = flatDict2.keys()
        valueCombos = itertools.product(*flatDict2.values())
        ps = [dict(zip(keys, combo)) for combo in valueCombos]
        paramsList.append(ps)
    return concat(paramsList)


class PipelineSubcommand(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

class Run(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads _inputPaths.yml into pipelib.INPUT_PATHS
        paramsList = expandParams(readParams(self.parent.paramsFile))
        from pprint import pprint
        for params in paramsList:
            print('Running {} pipeline with params:'.format(self.parent.__class__.__name__))
            pprint(params)
            self.parent.makePipeline(**params)

class Make(cli.Application):
    def main(self):
        yml = readParams(self.parent.paramsFile)
        for paramsDict in yml:
            for softname, commits in paramsDict['software'].items():
                recipeFile = local.path('software') / (softname + '.py')
                if not recipeFile.exists():
                    print("{} does not exist, maybe there is a typo in '{}'?".format(recipeFile, self.parent.paramsFile))
                    sys.exit(1)
                for commit in commits:
                    m = importlib.import_module('software.' + softname)
                    print('Make {} with commit {}'.format(softname, commit))
                    m.make(commit)
        print('Done.')


def classFactory(name, fn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return fn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        name = m.__name__[9:]
        SubcommandClass = classFactory(name, m.makePipeline)
        App.subcommand(name, SubcommandClass)
        SubcommandClass.subcommand("run", Run)
        SubcommandClass.subcommand("make", Make)
    App.run()
