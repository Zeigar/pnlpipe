#!/usr/bin/env python
try:
    from plumbum import local, FG, cli
except ImportError:
    print('Couldn\'t import plumbum')
    print(
        'Did you forget to load python environment? (e.g. source activate pnlpipe)')
import sys
import yaml
import pipelib
import pipelib
import itertools
import importlib
from pprint import pprint

inputPathsFile = "inputPaths.yml"

def makeGeneratedPathsYml(caseid, pipelines):
    paths = {'caseid': caseid}
    for idx, pipeline in enumerate(pipelines):
        for key, node in pipeline.items():
            if len(pipelines) == 1:
                paths[key] = str(node.path())
            else:
                paths[key + str(idx)] = str(node.path())
    return paths


def writeGeneratedPathsYml(caseid, pipelines):
    print('Make {}/paths.yml'.format(pipelib.OUTDIR))
    generatedPathsDict = makeGeneratedPathsYml(caseid, pipelines)
    with open('_data/paths.yml', 'w') as f:
        yaml.dump(generatedPathsDict, f, default_flow_style=False)
    print('Made {}/paths.yml'.format(pipelib.OUTDIR))
    print()


def readAndSetInputPaths():
    if not local.path(inputPathsFile).exists():
        print(
            "Missing {}, first make one using 'pnlscripts/makepathsyml.py' or a text editor".format(inputPathsFile))
        sys.exit(1)
    with open(inputPathsFile, 'r') as f:
        pipelib.INPUT_PATHS = yaml.load(f)

def loadSubmodules(package):
    import pkgutil
    from os.path import isfile
    for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
        if modname.startswith('pipeline_'):
            yield importer.find_module(modname).load_module(modname)

class App(cli.Application):

    want = cli.SwitchAttr(
        ['-w', '--want'], help='target node to build, e.g. fsindwi')

    caseid = cli.SwitchAttr(['--subjid', '-s'], help="Case/Subject id, will override the 'caseid' key in params.<pipeline> if it exists")

    writeGeneratedPathsYml = cli.Flag('--writePaths', default=False)

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

def checkPaths(pathsDict):
    allexist = True
    print('Check keys')
    for key, path in pathsDict.items():
        print('{}: {}'. format(key, path))
        if key == 'caseid':
            continue
        if not local.path(path).exists():
            print("'{}' does not exist, is this intended?".format(path))
            allexist = False
    if not pathsDict.get('caseid', None):
        print("Error: 'caseid' not set, make you set this so the pipeline knows how to get the paths for your other subjects.")
        print("'{}' not made".format(inputPathsFile))
        sys.exit(1)
    print('')
    if allexist:
        print('All paths exist.')
        return
    print("Warning: Some paths don't exist for the given caseid, so pipeline may fail to run.")


def writePaths(pathsDict, outfile):
    checkPaths(pathsDict)
    with open(outfile, 'w') as f:
        yaml.safe_dump(pathsDict, f, default_flow_style=False)
    print("Made '{}'".format(outfile))

def readPathsYml(pathsDir):
    pathsDict = {}
    with open(pathsDir / 'paths.yml', 'r') as f:
        try:
            relativePaths = yaml.load(f,  Loader=yaml.loader.BaseLoader)
        except yaml.parser.ParserError as err:
            print(err)
            print('Error parsing {}, is there a typo? (And are the path templates in quotes?)'.format(pathsDir/'paths.yml'))
            sys.exit(1)
    return relativePaths

@App.subcommand("init")
class PipeInit(cli.Application):
    """Creates input paths yaml file for this project."""

    fromdir = cli.SwitchAttr('--fromdir', cli.ExistingDirectory, help='from data directory with existing paths.yml')

    def main(self):
        if local.path(inputPathsFile).exists():
            print("'{}' already exists, won't overwrite.".format(inputPathsFile))
            return

        # Copy from paths.yml in another project directory
        if self.fromdir:
            dataDir = self.fromdir
            inputPaths = {}
            for key, val in readPathsYml(dataDir).items():
                if key == 'caseid':
                    inputPaths[key] = val
                else:
                    absolutePath = local.path(dataDir / val)
                    newPath = absolutePath.relative_to(local.path(inputPathsFile).dirname)
                    inputPaths[key] = str(newPath)
            writePaths(inputPaths, inputPathsFile)

        # Ncurses interface
        else:
            try:
                import npyscreen
                class MakePathsApp(npyscreen.NPSApp):
                    def main(self):
                        F  = npyscreen.Form(name = "Make a paths yaml file (TAB to autocomplete and ENTER/up/down to change fields",)
                        self.dwi = F.add(npyscreen.TitleFilename, name = "dwi:", begin_entry_at=24)
                        self.t1 = F.add(npyscreen.TitleFilename, name = "t1:", begin_entry_at=24)
                        #self.dwimask = F.add(npyscreen.TitleFilename, name = "dwimask:", begin_entry_at=24)
                        self.t2 = F.add(npyscreen.TitleFilename, name = "t2:", begin_entry_at=24)
                        self.caseid  = F.add(npyscreen.TitleText, name = "caseid:", begin_entry_at=24)

                        # This lets the user interact with the Form.
                        F.edit()


                NcursesApp = MakePathsApp()
                NcursesApp.run()
                inputPaths = {'caseid': NcursesApp.caseid.value}
                for key in ['dwi', 't1', 't2']:
                    if getattr(NcursesApp, key).value:
                        inputPaths[key] = getattr(NcursesApp,key).value
                writePaths(inputPaths, inputPathsFile)
            except ImportError:
                print(
"""Could not import npyscreen for ncurses interface, instead use a
text editor to make the yaml file ({}), with this format:

    t1: /project/dir/001/001-t1.ext
    dwi: /project/dir/001/001-dwi.ext
    caseid: 001""".format(inputPathsFile))
                sys.exit(1)



def concat(l):
    return l if l == [] else [item for sublist in l for item in sublist]

def readParams(ymlfile):
    with open(ymlfile, 'r') as f:
        yml = yaml.load(f)

    result = []
    for idx, paramDict in enumerate(yml if isinstance(yml,list) else [yml]):
        listValueDict = dict((k,v) if isinstance(v, list) else
                             (k,[v]) for k,v in paramDict.items())
        if not paramDict.get('caseid'):
            caselist = local.path('caselist.txt')
            if not caselist.exists():
                print("Add 'caseid' to {} (or save a caselist.txt to this directory)".format(ymlfile))
                sys.exit(1)
            print("Found './caselist.txt, using that for case id's")
            listValueDict['caseid'] = ['./caselist.txt']
        result.append(listValueDict)

    print("Read parameter file '{}':".format(ymlfile))
    pprint(result)
    return result


def expandParams(params):
    paramsList = []
    for paramsDict in params:
        # Check if case ids are defined by a caselist
        if '/' in paramsDict['caseid'][0]:
            with open(paramsDict['caseid'][0],'r') as f:
                paramsDict['caseid'] = f.read().splitlines()
        keys = paramsDict.keys()
        valueCombos = itertools.product(*paramsDict.values())
        ps = [dict(zip(keys, combo)) for combo in valueCombos]
        paramsList.append(ps)
    return concat(paramsList)


class PipelineSubcommand(cli.Application):
    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            return 1
        if not self.nested_command:
            print("No command given")
            return 1  # error exit code

class Run(cli.Application):
    def main(self):
        readAndSetInputPaths()  # reads inputPaths.yml into pipelib.INPUT_PATHS

        params = readParams(self.parent.paramsFile)
        if any('*mandatory*' in concat(p.values()) for p in params):
            print("'{}' has unfilled mandatory values, replace the '*mandatory*' fields first and then rerun the pipeline.".format(self.parent.paramsFile))
            sys.exit(1)

        if self.parent.parent.caseid:
            for paramsDict in params:
                if 'caseid' in paramsDict.keys():
                    paramsDict['caseid'] = [self.parent.parent.caseid]

        # Check all necessary software exists
        missingSoftware = []
        for module, commit in getSoftwareModules(params):
            if not local.path(module.getPath(commit)).exists():
                missingSoftware.append(module.getPath(commit))
        if missingSoftware:
            for soft in missingSoftware:
                print("Missing: {}".format(soft))
            print("Run './pipe {} make' first to build all prequisite software before running the pipeline again".format(self.parent.__class__.__name__))
            sys.exit(1)

        paramsList = expandParams(params)

        for params in paramsList:
            print('Running {} pipeline with paramaters:'.format(self.parent.__class__.__name__))
            pprint(params)

            pipeline = self.parent.makePipeline(**params)

            if not self.parent.parent.want:
                pipelib.update(pipeline['all'])
            else:
                pipelib.update(pipeline[self.parent.want])

def getSoftwareModules(yml):
    for paramsDict in yml:
        for softname, commits in [(k[5:],v) for (k,v) in paramsDict.items() if k.startswith('hash_')]:
            moduleFile = local.path('software') / (softname + '.py')
            if not moduleFile.exists():
                print("{} does not exist, maybe there is a typo in '{}'?".format(recipeFile, self.parent.paramsFile))
                sys.exit(1)
            module = importlib.import_module('software.' + softname)
            for commit in commits:
                yield (module, commit)


class Make(cli.Application):
    """ Builds necessary software for pipeline. """

    def main(self):
        yml = readParams(self.parent.paramsFile)
        for module, commit in getSoftwareModules(yml):
            print("Make {}".format(module.getPath(commit)))
            module.make(commit)
        print('Done.')

class Init(cli.Application):
    """Makes parameter file that is used as input for this pipeline."""

    force = cli.Flag(['--force'], help='Force overwrite existing paramater file.')

    def main(self):

        pipelineName = self.parent.__class__.__name__
        paramsFile = 'params.' + pipelineName
        if local.path(paramsFile).exists() and not self.force:
            print("'{}' already exists, won't overwrite (use '--force' to overwrite it).".format(paramsFile))
            return
        local.path(paramsFile).delete()
        import inspect
        from itertools import izip_longest
        from collections import OrderedDict
        args, _, _, defaults = inspect.getargspec(self.parent.makePipeline_orig)
        x = izip_longest(reversed(args), reversed(defaults), fillvalue='*mandatory*')
        paramDict = OrderedDict(reversed(list(x)))
        # get a default caseid
        paramDict['caseid'] = './caselist.txt'
        if (not local.path('caselist.txt').exists()) and local.path(inputPathsFile).exists():
            with open(inputPathsFile, 'r') as f:
                inputPaths = yaml.load(f)
                paramDict['caseid'] = inputPaths.get('caseid', './caselist.txt')
        """ http://stackoverflow.com/a/8661021 """
        represent_dict_order = lambda self, data:  self.represent_mapping('tag:yaml.org,2002:map', data.items())
        yaml.add_representer(OrderedDict, represent_dict_order)
        help_message = \
"""# Use one of the following formats for 'caseid'
# caseid: 001
# caseid: [001, 002, 003]
# caseid:
#    - 001
#    - 002
#    - 003
# caseid: ./caselist-controls.txt  # The '/' tells pipe that this is a file
"""
        with open(paramsFile, 'w') as f:
            f.write(help_message)
            yaml.dump(paramDict, f, default_flow_style=False)
        print("Made '{}'".format(paramsFile))
        print("Before running the pipeline, replace the '*mandatory*' fields:")
        print("# Edit {}, add your parameters".format(paramsFile))
        print("./pipe {} make".format(pipelineName))
        print("./pipe {} run".format(pipelineName))


def classFactory(name, makePipelineFn, BaseClass=PipelineSubcommand):
    def wrapFunction(self, *args, **kwargs):
        return makePipelineFn( *args, **kwargs)
    paramsFile = 'params.' + name
    newclass = type(name, (BaseClass,),{"makePipeline": wrapFunction
                                        ,"makePipeline_orig": makePipelineFn
                                        ,"paramsFile": paramsFile})
    return newclass


if __name__ == '__main__':
    import pipelines
    for m in loadSubmodules(pipelines):
        name = m.__name__[9:]
        SubcommandClass = classFactory(name, m.makePipeline)
        App.subcommand(name, SubcommandClass)
        SubcommandClass.subcommand("run", Run)
        SubcommandClass.subcommand("make", Make)
        SubcommandClass.subcommand("init", Init)
    App.run()
